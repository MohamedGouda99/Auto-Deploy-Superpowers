{"version":3,"file":"index.esm.min.js","sources":["../../src/metadata/ValidationMetadata.ts","../../src/validation-schema/ValidationSchemaToMetadataTransformer.ts","../../src/metadata/MetadataStorage.ts","../../src/validation/ValidationError.ts","../../src/validation/ValidationTypes.ts","../../src/utils.ts","../../src/validation/ValidationExecutor.ts","../../src/validation/ValidationUtils.ts","../../src/validation/Validator.ts","../../src/container.ts","../../src/decorator/common/Allow.ts","../../src/metadata/ConstraintMetadata.ts","../../src/register-decorator.ts","../../src/decorator/common/ValidateBy.ts","../../src/decorator/common/IsDefined.ts","../../src/decorator/common/IsOptional.ts","../../src/decorator/common/Validate.ts","../../src/decorator/common/ValidateIf.ts","../../src/decorator/common/ValidateNested.ts","../../src/decorator/common/ValidatePromise.ts","../../src/decorator/common/IsLatLong.ts","../../src/decorator/common/IsLatitude.ts","../../src/decorator/common/IsLongitude.ts","../../src/decorator/common/Equals.ts","../../src/decorator/common/NotEquals.ts","../../src/decorator/common/IsEmpty.ts","../../src/decorator/common/IsNotEmpty.ts","../../src/decorator/common/IsIn.ts","../../src/decorator/common/IsNotIn.ts","../../src/decorator/number/IsDivisibleBy.ts","../../src/decorator/number/IsPositive.ts","../../src/decorator/number/IsNegative.ts","../../src/decorator/number/Max.ts","../../src/decorator/number/Min.ts","../../src/decorator/date/MinDate.ts","../../src/decorator/date/MaxDate.ts","../../src/decorator/string/Contains.ts","../../src/decorator/string/NotContains.ts","../../src/decorator/string/IsAlpha.ts","../../src/decorator/string/IsAlphanumeric.ts","../../src/decorator/string/IsDecimal.ts","../../src/decorator/string/IsAscii.ts","../../src/decorator/string/IsBase64.ts","../../src/decorator/string/IsByteLength.ts","../../src/decorator/string/IsCreditCard.ts","../../src/decorator/string/IsCurrency.ts","../../src/decorator/string/IsEmail.ts","../../src/decorator/string/IsFQDN.ts","../../src/decorator/string/IsFullWidth.ts","../../src/decorator/string/IsHalfWidth.ts","../../src/decorator/string/IsVariableWidth.ts","../../src/decorator/string/IsHexColor.ts","../../src/decorator/string/IsHexadecimal.ts","../../src/decorator/ValidationOptions.ts","../../src/decorator/string/IsMacAddress.ts","../../src/decorator/string/IsIP.ts","../../src/decorator/string/IsPort.ts","../../src/decorator/string/IsISBN.ts","../../src/decorator/string/IsISIN.ts","../../src/decorator/string/IsISO8601.ts","../../src/decorator/string/IsJSON.ts","../../src/decorator/string/IsJWT.ts","../../src/decorator/string/IsLowercase.ts","../../src/decorator/string/IsMobilePhone.ts","../../src/decorator/string/IsISO31661Alpha2.ts","../../src/decorator/string/IsISO31661Alpha3.ts","../../src/decorator/string/IsMongoId.ts","../../src/decorator/string/IsMultibyte.ts","../../src/decorator/string/IsSurrogatePair.ts","../../src/decorator/string/IsUrl.ts","../../src/decorator/string/IsUUID.ts","../../src/decorator/string/IsFirebasePushId.ts","../../src/decorator/string/IsUppercase.ts","../../src/decorator/string/Length.ts","../../src/decorator/string/MaxLength.ts","../../src/decorator/string/MinLength.ts","../../src/decorator/string/Matches.ts","../../src/decorator/string/IsPhoneNumber.ts","../../src/decorator/string/IsMilitaryTime.ts","../../src/decorator/string/IsHash.ts","../../src/decorator/string/IsISSN.ts","../../src/decorator/string/IsDateString.ts","../../src/decorator/string/IsBooleanString.ts","../../src/decorator/string/IsNumberString.ts","../../src/decorator/string/IsBase32.ts","../../src/decorator/string/IsBIC.ts","../../src/decorator/string/IsBtcAddress.ts","../../src/decorator/string/IsDataURI.ts","../../src/decorator/string/IsEAN.ts","../../src/decorator/string/IsEthereumAddress.ts","../../src/decorator/string/IsHSL.ts","../../src/decorator/string/IsIBAN.ts","../../src/decorator/string/IsIdentityCard.ts","../../src/decorator/string/IsISRC.ts","../../src/decorator/string/IsLocale.ts","../../src/decorator/string/IsMagnetURI.ts","../../src/decorator/string/IsMimeType.ts","../../src/decorator/string/IsOctal.ts","../../src/decorator/string/IsPassportNumber.ts","../../src/decorator/string/IsPostalCode.ts","../../src/decorator/string/IsRFC3339.ts","../../src/decorator/string/IsRgbColor.ts","../../src/decorator/string/IsSemVer.ts","../../src/decorator/typechecker/IsBoolean.ts","../../src/decorator/typechecker/IsDate.ts","../../src/decorator/typechecker/IsNumber.ts","../../src/decorator/typechecker/IsEnum.ts","../../src/decorator/typechecker/IsInt.ts","../../src/decorator/typechecker/IsString.ts","../../src/decorator/typechecker/IsArray.ts","../../src/decorator/typechecker/IsObject.ts","../../src/decorator/array/ArrayContains.ts","../../src/decorator/array/ArrayNotContains.ts","../../src/decorator/array/ArrayNotEmpty.ts","../../src/decorator/array/ArrayMinSize.ts","../../src/decorator/array/ArrayMaxSize.ts","../../src/decorator/array/ArrayUnique.ts","../../src/decorator/object/IsNotEmptyObject.ts","../../src/decorator/object/IsInstance.ts","../../src/index.ts"],"sourcesContent":["import {ValidationMetadataArgs} from \"./ValidationMetadataArgs\";\nimport {ValidationArguments} from \"../validation/ValidationArguments\";\n\n/**\n * This metadata contains validation rules.\n */\nexport class ValidationMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validation type.\n     */\n    type: string;\n\n    /**\n     * Target class to which this validation is applied.\n     */\n    target: Function|string;\n\n    /**\n     * Property of the object to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Constraint class that performs validation. Used only for custom validations.\n     */\n    constraintCls: Function;\n\n    /**\n     * Array of constraints of this validation.\n     */\n    constraints: any[];\n\n    /**\n     * Validation message to be shown in the case of error.\n     */\n    message: string|((args: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups: string[] = [];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always: boolean = false;\n\n    /**\n     * Specifies if validated value is an array and each of its item must be validated.\n     */\n    each: boolean = false;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any = undefined;\n\n    /**\n     * Extra options specific to validation type.\n     */\n    validationTypeOptions: any;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(args: ValidationMetadataArgs) {\n        this.type = args.type;\n        this.target = args.target;\n        this.propertyName = args.propertyName;\n        this.constraints = args.constraints;\n        this.constraintCls = args.constraintCls;\n        this.validationTypeOptions = args.validationTypeOptions;\n        if (args.validationOptions) {\n            this.message = args.validationOptions.message;\n            this.groups = args.validationOptions.groups;\n            this.always = args.validationOptions.always;\n            this.each = args.validationOptions.each;\n            this.context = args.validationOptions.context;\n        }\n    }\n\n}\n","import {ValidationSchema} from \"./ValidationSchema\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"../metadata/ValidationMetadataArgs\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport {ValidationTypes} from \"../validation/ValidationTypes\";\n\n/**\n * Used to transform validation schemas to validation metadatas.\n */\nexport class ValidationSchemaToMetadataTransformer {\n\n    transform(schema: ValidationSchema): ValidationMetadata[] {\n        const metadatas: ValidationMetadata[] = [];\n        Object.keys(schema.properties).forEach(property => {\n            schema.properties[property].forEach(validation => {\n                const validationOptions: ValidationOptions = {\n                    message: validation.message,\n                    groups: validation.groups,\n                    always: validation.always,\n                    each: validation.each\n                };\n                const args: ValidationMetadataArgs = {\n                    type: validation.type,\n                    target: schema.name,\n                    propertyName: property,\n                    constraints: validation.constraints,\n                    validationTypeOptions: validation.options,\n                    validationOptions: validationOptions\n                };\n                metadatas.push(new ValidationMetadata(args));\n            });\n        });\n        return metadatas;\n    }\n\n}\n","import {ValidationMetadata} from \"./ValidationMetadata\";\nimport {ConstraintMetadata} from \"./ConstraintMetadata\";\nimport {ValidationSchema} from \"../validation-schema/ValidationSchema\";\nimport {ValidationSchemaToMetadataTransformer} from \"../validation-schema/ValidationSchemaToMetadataTransformer\";\n\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage(): MetadataStorage {\n    if (typeof window !== \"undefined\") {\n        (window as any).global = window;\n    }\n    if (!(global as any).classValidatorMetadataStorage)\n        (global as any).classValidatorMetadataStorage = new MetadataStorage();\n\n    return (global as any).classValidatorMetadataStorage;\n}\n\n/**\n * Storage all metadatas.\n */\nexport class MetadataStorage {\n\n    // -------------------------------------------------------------------------\n    // Private properties\n    // -------------------------------------------------------------------------\n\n    private validationMetadatas: ValidationMetadata[] = [];\n    private constraintMetadatas: ConstraintMetadata[] = [];\n\n    get hasValidationMetaData() {\n        return !!this.validationMetadatas.length;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationSchema(schema: ValidationSchema) {\n        const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n        validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n    }\n\n    /**\n     * Adds a new validation metadata.\n     */\n    addValidationMetadata(metadata: ValidationMetadata) {\n        this.validationMetadatas.push(metadata);\n    }\n\n    /**\n     * Adds a new constraint metadata.\n     */\n    addConstraintMetadata(metadata: ConstraintMetadata) {\n        this.constraintMetadatas.push(metadata);\n    }\n\n    /**\n     * Groups metadata by their property names.\n     */\n    groupByPropertyName(metadata: ValidationMetadata[]): { [propertyName: string]: ValidationMetadata[] } {\n        const grouped: { [propertyName: string]: ValidationMetadata[] } = {};\n        metadata.forEach(metadata => {\n            if (!grouped[metadata.propertyName])\n                grouped[metadata.propertyName] = [];\n            grouped[metadata.propertyName].push(metadata);\n        });\n        return grouped;\n    }\n\n    /**\n     * Gets all validation metadatas for the given object with the given groups.\n     */\n    getTargetValidationMetadatas(targetConstructor: Function, targetSchema: string, groups?: string[]): ValidationMetadata[] {\n\n        // get directly related to a target metadatas\n        const originalMetadatas = this.validationMetadatas.filter(metadata => {\n            if (metadata.target !== targetConstructor && metadata.target !== targetSchema)\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // get metadatas for inherited classes\n        const inheritedMetadatas = this.validationMetadatas.filter(metadata => {\n            // if target is a string it's means we validate agains a schema, and there is no inheritance support for schemas\n            if (typeof metadata.target === \"string\")\n                return false;\n            if (metadata.target === targetConstructor)\n                return false;\n            if (metadata.target instanceof Function &&\n                !(targetConstructor.prototype instanceof (metadata.target as Function)))\n                return false;\n            if (metadata.always)\n                return true;\n            if (groups && groups.length > 0)\n                return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n            return true;\n        });\n\n        // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n        const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n            return !originalMetadatas.find(originalMetadata => {\n                return  originalMetadata.propertyName === inheritedMetadata.propertyName &&\n                        originalMetadata.type === inheritedMetadata.type;\n            });\n        });\n\n        return originalMetadatas.concat(uniqueInheritedMetadatas);\n    }\n\n    /**\n     * Gets all validator constraints for the given object.\n     */\n    getTargetValidatorConstraints(target: Function): ConstraintMetadata[] {\n        return this.constraintMetadatas.filter(metadata => metadata.target === target);\n    }\n\n}\n","/**\n * Validation error description.\n */\nexport class ValidationError {\n\n    /**\n     * Object that was validated.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.target option\n     */\n    target?: Object;\n\n    /**\n     * Object's property that haven't pass validation.\n     */\n    property: string;\n\n    /**\n     * Value that haven't pass a validation.\n     *\n     * OPTIONAL - configurable via the ValidatorOptions.validationError.value option\n     */\n    value?: any;\n\n    /**\n     * Constraints that failed validation with error messages.\n     */\n    constraints?: {\n        [type: string]: string\n    };\n\n    /**\n     * Contains all nested validation errors of the property.\n     */\n    children: ValidationError[];\n\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    contexts?: {\n        [type: string]: any\n    };\n\n    /**\n     *\n     * @param shouldDecorate decorate the message with ANSI formatter escape codes for better readability\n     * @param hasParent true when the error is a child of an another one\n     * @param parentPath path as string to the parent of this property\n     */\n    toString(shouldDecorate: boolean = false, hasParent: boolean = false, parentPath: string = ``): string {\n        const boldStart = shouldDecorate ? `\\x1b[1m` : ``;\n        const boldEnd = shouldDecorate ? `\\x1b[22m` : ``;\n        const propConstraintFailed = (propertyName: string): string => ` - property ${boldStart}${parentPath}${propertyName}${boldEnd} has failed the following constraints: ${boldStart}${Object.keys(this.constraints).join(`, `)}${boldEnd} \\n`;\n\n        if (!hasParent) {\n            return `An instance of ${boldStart}${this.target ? this.target.constructor.name : \"an object\"}${boldEnd} has failed the validation:\\n` +\n                (this.constraints ? propConstraintFailed(this.property) : ``) +\n                this.children\n                    .map(childError => childError.toString(shouldDecorate, true, this.property))\n                    .join(``);\n        } else {\n            // we format numbers as array indexes for better readability.\n            const formattedProperty = Number.isInteger(+this.property) ? `[${this.property}]` : `${parentPath ? `.` : ``}${this.property}`;\n\n            if (this.constraints) {\n                return propConstraintFailed(formattedProperty);\n            } else {\n                return this.children\n                    .map(childError => childError.toString(shouldDecorate, true, `${parentPath}${formattedProperty}`, ))\n                    .join(``);\n            }\n        }\n    }\n}\n","/**\n * Validation types.\n */\nexport class ValidationTypes {\n\n    /* system */\n    static CUSTOM_VALIDATION = \"customValidation\"; // done\n    static NESTED_VALIDATION = \"nestedValidation\"; // done\n    static PROMISE_VALIDATION = \"promiseValidation\"; // done\n    static CONDITIONAL_VALIDATION = \"conditionalValidation\"; // done\n    static WHITELIST = \"whitelistValidation\"; // done\n    static IS_DEFINED = \"isDefined\"; // done\n\n    /**\n     * Checks if validation type is valid.\n     */\n    static isValid(type: string) {\n        return type !== \"isValid\" &&\n            type !== \"getMessage\" &&\n            Object.keys(this).map(key => (this as any)[key]).indexOf(type) !== -1;\n    }\n\n}\n","// https://github.com/TylorS/typed-is-promise/blob/abf1514e1b6961adfc75765476b0debb96b2c3ae/src/index.ts\n\nexport function isPromise<T = any>(p: any): p is Promise<T> {\n    return p !== null && typeof p === \"object\" && typeof p.then === \"function\";\n}\n\n/**\n * Convert Map, Set to Array\n */\nexport function convertToArray<T>(val: Array<T> | Set<T> | Map<any, T>): Array<T> {\n    if (val instanceof Map) {\n        return Array.from(val.values());\n    }\n    return Array.isArray(val) ? val : Array.from(val);\n}\n","import {Validator} from \"./Validator\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ConstraintMetadata} from \"../metadata/ConstraintMetadata\";\nimport {ValidationArguments} from \"./ValidationArguments\";\nimport {ValidationUtils} from \"./ValidationUtils\";\nimport {isPromise, convertToArray} from \"../utils\";\nimport { getMetadataStorage } from \"../metadata/MetadataStorage\";\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    awaitingPromises: Promise<any>[] = [];\n    ignoreAsyncValidations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private metadataStorage = getMetadataStorage();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private validator: Validator,\n                private validatorOptions?: ValidatorOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    execute(object: Object, targetSchema: string, validationErrors: ValidationError[]) {\n        /**\n         * If there is no metadata registered it means possibly the dependencies are not flatterned and\n         * more than one instance is used.\n         *\n         * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n         */\n        if (!this.metadataStorage.hasValidationMetaData) {\n            console.warn(`No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.`);\n        }\n\n        const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n        const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(object.constructor, targetSchema, groups);\n        const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n        if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {\n            const validationError = new ValidationError();\n\n            if (!this.validatorOptions ||\n                !this.validatorOptions.validationError ||\n                this.validatorOptions.validationError.target === undefined ||\n                this.validatorOptions.validationError.target === true)\n                validationError.target = object;\n\n            validationError.value = undefined;\n            validationError.property = undefined;\n            validationError.children = [];\n            validationError.constraints = { unknownValue: \"an unknown value was passed to the validate function\" };\n\n            validationErrors.push(validationError);\n\n            return;\n        }\n\n        if (this.validatorOptions && this.validatorOptions.whitelist)\n            this.whitelist(object, groupedMetadatas, validationErrors);\n\n        // General validation\n        Object.keys(groupedMetadatas).forEach(propertyName => {\n            const value = (object as any)[propertyName];\n            const definedMetadatas = groupedMetadatas[propertyName].filter(metadata => metadata.type === ValidationTypes.IS_DEFINED);\n            const metadatas = groupedMetadatas[propertyName].filter(\n              metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST);\n\n            if (value instanceof Promise && metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)) {\n                this.awaitingPromises.push(value.then((resolvedValue) => {\n                    this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n                }));\n            } else {\n                this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n            }\n        });\n    }\n\n    whitelist(object: any,\n              groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n              validationErrors: ValidationError[]) {\n        let notAllowedProperties: string[] = [];\n\n        Object.keys(object).forEach(propertyName => {\n            // does this property have no metadata?\n            if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n                notAllowedProperties.push(propertyName);\n        });\n\n        if (notAllowedProperties.length > 0) {\n\n            if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n\n                // throw errors\n                notAllowedProperties.forEach(property => {\n                    const validationError: ValidationError = this.generateValidationError(object, (object as any)[property], property);\n                    validationError.constraints = { [ValidationTypes.WHITELIST]: `property ${property} should not exist` };\n                    validationError.children = undefined;\n                    validationErrors.push(validationError);\n                });\n\n            } else {\n\n                // strip non allowed properties\n                notAllowedProperties.forEach(property => delete (object as any)[property]);\n\n            }\n        }\n    }\n\n    stripEmptyErrors(errors: ValidationError[]) {\n        return errors.filter(error => {\n            if (error.children) {\n                error.children = this.stripEmptyErrors(error.children);\n            }\n\n            if (Object.keys(error.constraints).length === 0) {\n                if (error.children.length === 0) {\n                    return false;\n                } else {\n                    delete error.constraints;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private performValidations (object: any,\n                                value: any, propertyName: string,\n                                definedMetadatas: ValidationMetadata[],\n                                metadatas: ValidationMetadata[],\n                                validationErrors: ValidationError[]) {\n\n        const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n        const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n        const conditionalValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION);\n\n        const validationError = this.generateValidationError(object, value, propertyName);\n        validationErrors.push(validationError);\n\n        const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n        if (!canValidate) {\n            return;\n        }\n\n        // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n        this.customValidations(object, value, definedMetadatas, validationError);\n        this.mapContexts(object, value, definedMetadatas, validationError);\n\n        if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n            return;\n        }\n\n        if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n            return;\n        }\n\n        if ((value === null || value === undefined) && this.validatorOptions && this.validatorOptions.skipMissingProperties === true) {\n            return;\n        }\n\n        this.customValidations(object, value, customValidationMetadatas, validationError);\n        this.nestedValidations(value, nestedValidationMetadatas, validationError.children, definedMetadatas, metadatas);\n\n        this.mapContexts(object, value, metadatas, validationError);\n        this.mapContexts(object, value, customValidationMetadatas, validationError);\n    }\n\n    private generateValidationError(object: Object, value: any, propertyName: string) {\n        const validationError = new ValidationError();\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.target === undefined ||\n            this.validatorOptions.validationError.target === true)\n            validationError.target = object;\n\n        if (!this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.value === undefined ||\n            this.validatorOptions.validationError.value === true)\n            validationError.value = value;\n\n        validationError.property = propertyName;\n        validationError.children = [];\n        validationError.constraints = {};\n\n        return validationError;\n    }\n\n    private conditionalValidations(object: Object,\n                                   value: any,\n                                   metadatas: ValidationMetadata[]) {\n        return metadatas\n            .map(metadata => metadata.constraints[0](object, value))\n            .reduce((resultA, resultB) => resultA && resultB, true);\n    }\n\n    private customValidations(object: Object,\n                              value: any,\n                              metadatas: ValidationMetadata[],\n                              error: ValidationError) {\n\n        metadatas.forEach(metadata => {\n            this.metadataStorage\n                .getTargetValidatorConstraints(metadata.constraintCls)\n                .forEach(customConstraintMetadata => {\n                    if (customConstraintMetadata.async && this.ignoreAsyncValidations)\n                        return;\n\n                    const validationArguments: ValidationArguments = {\n                        targetName: object.constructor ? (object.constructor as any).name : undefined,\n                        property: metadata.propertyName,\n                        object: object,\n                        value: value,\n                        constraints: metadata.constraints\n                    };\n\n                    if (!metadata.each || !(value instanceof Array || value instanceof Set || value instanceof Map)) {\n                        const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n                        if (isPromise(validatedValue)) {\n                            const promise = validatedValue.then(isValid => {\n                                if (!isValid) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n                            this.awaitingPromises.push(promise);\n                        } else {\n                            if (!validatedValue) {\n                                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                error.constraints[type] = message;\n                            }\n                        }\n\n                        return;\n                    }\n\n                    // convert set and map into array\n                    const arrayValue = convertToArray(value);\n                    // Validation needs to be applied to each array item\n                    const validatedSubValues = arrayValue.map((subValue: any) => customConstraintMetadata.instance.validate(subValue, validationArguments));\n                    const validationIsAsync = validatedSubValues\n                        .some((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue));\n\n                    if (validationIsAsync) {\n                        // Wrap plain values (if any) in promises, so that all are async\n                        const asyncValidatedSubValues = validatedSubValues\n                            .map((validatedSubValue: boolean | Promise<boolean>) => isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue));\n                        const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues)\n                            .then((flatValidatedValues: boolean[]) => {\n                                const validationResult = flatValidatedValues.every((isValid: boolean) => isValid);\n                                if (!validationResult) {\n                                    const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                                    error.constraints[type] = message;\n                                    if (metadata.context) {\n                                        if (!error.contexts) {\n                                            error.contexts = {};\n                                        }\n                                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                                    }\n                                }\n                            });\n\n                        this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n\n                        return;\n                    }\n\n                    const validationResult = validatedSubValues.every((isValid: boolean) => isValid);\n                    if (!validationResult) {\n                        const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                        error.constraints[type] = message;\n                    }\n                });\n        });\n    }\n\n    private nestedValidations(value: any, metadatas: ValidationMetadata[], errors: ValidationError[],\n                              definedMetadatas: ValidationMetadata[], allMetadatas: ValidationMetadata[]) {\n\n        if (value === void 0) {\n            return;\n        }\n\n        metadatas.forEach(metadata => {\n            if (\n                metadata.type !== ValidationTypes.NESTED_VALIDATION &&\n                metadata.type !== ValidationTypes.PROMISE_VALIDATION\n            ) {\n                return;\n            }\n\n            if (value instanceof Array || value instanceof Set || value instanceof Map) {\n                // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n                const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n                arrayLikeValue.forEach((subValue: any, index: any) => {\n                    this.performValidations(value, subValue, index.toString(), definedMetadatas, allMetadatas, errors);\n                });\n            } else if (value instanceof Object) {\n                const targetSchema = typeof metadata.target === \"string\" ? metadata.target as string : metadata.target.name;\n                this.execute(value, targetSchema, errors);\n\n            } else {\n                const error = new ValidationError();\n                error.value = value;\n                error.property = metadata.propertyName;\n                error.target = metadata.target;\n                const [type, message] = this.createValidationError(metadata.target, value, metadata);\n                error.constraints = {\n                    [type]: message\n                };\n                errors.push(error);\n            }\n        });\n    }\n\n    private mapContexts(object: Object,\n                        value: any,\n                        metadatas: ValidationMetadata[],\n                        error: ValidationError) {\n\n        return metadatas\n            .forEach(metadata => {\n                if (metadata.context) {\n                    let customConstraint;\n                    if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {\n                        const customConstraints = this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);\n                        customConstraint = customConstraints[0];\n                    }\n\n                    const type = this.getConstraintType(metadata, customConstraint);\n\n                    if (error.constraints[type]) {\n                        if (!error.contexts) {\n                            error.contexts = {};\n                        }\n\n                        error.contexts[type] = Object.assign((error.contexts[type] || {}), metadata.context);\n                    }\n                }\n            });\n    }\n\n    private createValidationError(object: Object,\n                                  value: any,\n                                  metadata: ValidationMetadata,\n                                  customValidatorMetadata?: ConstraintMetadata): [string, string] {\n\n        const targetName = object.constructor ? (object.constructor as any).name : undefined;\n        const type = this.getConstraintType(metadata, customValidatorMetadata);\n        const validationArguments: ValidationArguments = {\n            targetName: targetName,\n            property: metadata.propertyName,\n            object: object,\n            value: value,\n            constraints: metadata.constraints\n        };\n\n        let message = metadata.message || \"\";\n        if (!metadata.message &&\n            (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))) {\n            if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n                message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n            }\n        }\n\n        const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n        return [type, messageString];\n    }\n\n    private getConstraintType(metadata: ValidationMetadata, customValidatorMetadata?: ConstraintMetadata): string {\n        const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n        return type;\n    }\n\n}\n","import {ValidationArguments} from \"./ValidationArguments\";\n\nexport class ValidationUtils {\n\n    static replaceMessageSpecialTokens(message: string|((args: ValidationArguments) => string),\n                                validationArguments: ValidationArguments): string {\n\n        let messageString: string;\n        if (message instanceof Function) {\n            messageString = (message as (args: ValidationArguments) => string)(validationArguments);\n\n        } else if (typeof message === \"string\") {\n            messageString = message as string;\n        }\n\n        if (messageString && validationArguments.constraints instanceof Array) {\n            validationArguments.constraints.forEach((constraint, index) => {\n                messageString = messageString.replace(new RegExp(`\\\\$constraint${index + 1}`, \"g\"), constraint);\n            });\n        }\n\n        if (messageString && validationArguments.value !== undefined && validationArguments.value !== null && typeof validationArguments.value === \"string\")\n            messageString = messageString.replace(/\\$value/g, validationArguments.value);\n        if (messageString)\n            messageString = messageString.replace(/\\$property/g, validationArguments.property);\n        if (messageString)\n            messageString = messageString.replace(/\\$target/g, validationArguments.targetName);\n\n        return messageString;\n    }\n    \n}","import {ValidationMetadata} from \"../metadata/ValidationMetadata\";\nimport {ValidationTypes} from \"./ValidationTypes\";\nimport {ValidationError} from \"./ValidationError\";\nimport {ValidatorOptions} from \"./ValidatorOptions\";\nimport {ValidationExecutor} from \"./ValidationExecutor\";\nimport {ValidationOptions} from \"../decorator/ValidationOptions\";\nimport * as validator from \"validator\";\n\n/**\n * Validator performs validation of the given object based on its metadata.\n */\nexport class Validator {\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     * Common method for `validateOrReject` and `validate` methods.\n     */\n    private coreValidate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n\n        return Promise.all(executor.awaitingPromises).then(() => {\n            return executor.stripEmptyErrors(validationErrors);\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     */\n    validate(object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validate(schemaName: string, object: Object, options?: ValidatorOptions): Promise<ValidationError[]>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validate(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n        return this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class and reject on error.\n     */\n    validateOrReject(object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on validation schema and reject on error.\n     */\n    validateOrReject(schemaName: string, object: Object, options?: ValidatorOptions): Promise<void>;\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema and reject on error.\n     */\n    async validateOrReject(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n        const errors = await this.coreValidate(objectOrSchemaName, objectOrValidationOptions, maybeValidatorOptions);\n        if (errors.length)\n            return Promise.reject(errors);\n    }\n\n    /**\n     * Performs validation of the given object based on decorators used in given object class.\n     * NOTE: This method completely ignores all async validations.\n     */\n    validateSync(object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on validation schema.\n     */\n    validateSync(schemaName: string, object: Object, options?: ValidatorOptions): ValidationError[];\n\n    /**\n     * Performs validation of the given object based on decorators or validation schema.\n     */\n    validateSync(objectOrSchemaName: Object|string, objectOrValidationOptions: Object|ValidationOptions, maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n        const object = typeof objectOrSchemaName === \"string\" ? objectOrValidationOptions as Object : objectOrSchemaName as Object;\n        const options = typeof objectOrSchemaName === \"string\" ? maybeValidatorOptions : objectOrValidationOptions as ValidationOptions;\n        const schema = typeof objectOrSchemaName === \"string\" ? objectOrSchemaName as string : undefined;\n\n        const executor = new ValidationExecutor(this, options);\n        executor.ignoreAsyncValidations = true;\n        const validationErrors: ValidationError[] = [];\n        executor.execute(object, schema, validationErrors);\n        return executor.stripEmptyErrors(validationErrors);\n    }\n\n}\n","\n/**\n * Container options.\n */\nexport interface UseContainerOptions {\n\n    /**\n     * If set to true, then default container will be used in the case if given container haven't returned anything.\n     */\n    fallback?: boolean;\n\n    /**\n     * If set to true, then default container will be used in the case if given container thrown an exception.\n     */\n    fallbackOnErrors?: boolean;\n\n}\n\n/**\n * Container to be used by this library for inversion control. If container was not implicitly set then by default\n * container simply creates a new instance of the given class.\n */\nconst defaultContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T } = new (class {\n    private instances: { type: Function, object: any }[] = [];\n    get<T>(someClass: { new (...args: any[]): T }): T {\n        let instance = this.instances.find(instance => instance.type === someClass);\n        if (!instance) {\n            instance = { type: someClass, object: new someClass() };\n            this.instances.push(instance);\n        }\n\n        return instance.object;\n    }\n})();\n\nlet userContainer: { get<T>(someClass: { new (...args: any[]): T }|Function): T };\nlet userContainerOptions: UseContainerOptions;\n\n/**\n * Sets container to be used by this library.\n */\nexport function useContainer(iocContainer: { get(someClass: any): any }, options?: UseContainerOptions) {\n    userContainer = iocContainer;\n    userContainerOptions = options;\n}\n\n/**\n * Gets the IOC container used by this library.\n */\nexport function getFromContainer<T>(someClass: { new (...args: any[]): T }|Function): T {\n    if (userContainer) {\n        try {\n            const instance = userContainer.get(someClass);\n            if (instance)\n                return instance;\n\n            if (!userContainerOptions || !userContainerOptions.fallback)\n                return instance;\n\n        } catch (error) {\n            if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)\n                throw error;\n        }\n    }\n    return defaultContainer.get<T>(someClass);\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * If object has both allowed and not allowed properties a validation error will be thrown.\n */\nexport function Allow(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.WHITELIST,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import {ValidatorConstraintInterface} from \"../validation/ValidatorConstraintInterface\";\nimport {getFromContainer} from \"../container\";\n\n/**\n * This metadata interface contains information for custom validators.\n */\nexport class ConstraintMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Target class which performs validation.\n     */\n    target: Function;\n\n    /**\n     * Custom validation's name, that will be used as validation error type.\n     */\n    name: string;\n\n    /**\n     * Indicates if this validation is asynchronous or not.\n     */\n    async: boolean;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(target: Function, name?: string, async: boolean = false) {\n        this.target = target;\n        this.name = name;\n        this.async = async;\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Instance of the target custom validation class which performs validation.\n     */\n    get instance(): ValidatorConstraintInterface {\n        return getFromContainer<ValidatorConstraintInterface>(this.target);\n    }\n\n}\n","import {ConstraintMetadata} from \"./metadata/ConstraintMetadata\";\nimport {ValidatorConstraintInterface} from \"./validation/ValidatorConstraintInterface\";\nimport {ValidationMetadata} from \"./metadata/ValidationMetadata\";\nimport {ValidationMetadataArgs} from \"./metadata/ValidationMetadataArgs\";\nimport {ValidationTypes} from \"./validation/ValidationTypes\";\nimport {ValidationArguments} from \"./validation/ValidationArguments\";\nimport { getFromContainer } from \"./container\";\nimport { MetadataStorage, getMetadataStorage } from \"./metadata/MetadataStorage\";\nimport { ValidationOptions } from \"./decorator/ValidationOptions\";\n\nexport interface ValidationDecoratorOptions {\n\n    /**\n     * Target object to be validated.\n     */\n    target: Function;\n\n    /**\n     * Target object's property name to be validated.\n     */\n    propertyName: string;\n\n    /**\n     * Name of the validation that is being registered.\n     */\n    name?: string;\n\n    /**\n     * Indicates if this decorator will perform async validation.\n     */\n    async?: boolean;\n\n    /**\n     * Validator options.\n     */\n    options?: ValidationOptions;\n\n    /**\n     * Array of validation constraints.\n     */\n    constraints?: any[];\n\n    /**\n     * Validator that performs validation.\n     */\n    validator: ValidatorConstraintInterface|Function;\n}\n\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options: ValidationDecoratorOptions): void {\n\n    let constraintCls: Function;\n    if (options.validator instanceof Function) {\n        constraintCls = options.validator as Function;\n        const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n        if (constraintClasses.length > 1) {\n            throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target}:${options.propertyName}`;\n        }\n    } else {\n        const validator = options.validator as ValidatorConstraintInterface;\n        constraintCls = class CustomConstraint implements ValidatorConstraintInterface {\n            validate(value: any, validationArguments?: ValidationArguments): Promise<boolean>|boolean {\n                return validator.validate(value, validationArguments);\n            }\n\n            defaultMessage(validationArguments?: ValidationArguments) {\n                if (validator.defaultMessage) {\n                    return validator.defaultMessage(validationArguments);\n                }\n\n                return \"\";\n            }\n        };\n        getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n    }\n\n    const validationMetadataArgs: ValidationMetadataArgs = {\n        type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n        target: options.target,\n        propertyName: options.propertyName,\n        validationOptions: options.options,\n        constraintCls: constraintCls,\n        constraints: options.constraints\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { registerDecorator } from \"../../register-decorator\";\nimport { ValidationArguments } from \"../../validation/ValidationArguments\";\nimport { ValidatorConstraintInterface } from \"../../validation/ValidatorConstraintInterface\";\n\nexport interface ValidateByOptions {\n    name: string;\n    constraints?: any[];\n    validator: ValidatorConstraintInterface | Function;\n    async?: boolean;\n}\n\nexport function buildMessage(\n    impl: (eachPrefix: string, args?: ValidationArguments) => string,\n    validationOptions?: ValidationOptions)\n    : (validationArguments?: ValidationArguments) => string {\n    return (validationArguments?: ValidationArguments) => {\n        const eachPrefix = validationOptions && validationOptions.each\n            ? \"each value in \"\n            : \"\";\n        return impl(eachPrefix, validationArguments);\n    };\n}\n\nexport function ValidateBy(options: ValidateByOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        registerDecorator({\n            name: options.name,\n            target: object.constructor,\n            propertyName: propertyName,\n            options: validationOptions,\n            constraints: options.constraints,\n            validator: options.validator\n        });\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\n\n// isDefined is (yet) a special case\nexport const IS_DEFINED = ValidationTypes.IS_DEFINED;\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function isDefined(value: any): boolean {\n    return value !== undefined && value !== null;\n}\n\n/**\n * Checks if value is defined (!== undefined, !== null).\n */\nexport function IsDefined(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DEFINED,\n            validator: {\n                validate: (value) => isDefined(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be null or undefined\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Checks if value is missing and if so, ignores all validators.\n */\nexport function IsOptional(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [(object: any, value: any) => {\n                return object[propertyName] !== null && object[propertyName] !== undefined;\n            }],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ConstraintMetadata } from \"../../metadata/ConstraintMetadata\";\n\n/**\n * Registers custom validator class.\n */\nexport function ValidatorConstraint(options?: { name?: string, async?: boolean }) {\n    return function (target: Function) {\n        const isAsync = options && options.async ? true : false;\n        let name = options && options.name ? options.name : \"\";\n        if (!name) {\n            name = (target as any).name;\n            if (!name) // generate name if it was not given\n                name = name.replace(/\\.?([A-Z]+)/g, (x, y) => \"_\" + y.toLowerCase()).replace(/^_/, \"\");\n        }\n        const metadata = new ConstraintMetadata(target, name, isAsync);\n        getMetadataStorage().addConstraintMetadata(metadata);\n    };\n}\n\n/**\n * Performs validation based on the given custom validation class.\n * Validation class must be decorated with ValidatorConstraint decorator.\n */\nexport function Validate(constraintClass: Function, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraints?: any[], validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Validate(constraintClass: Function, constraintsOrValidationOptions?: any[] | ValidationOptions, maybeValidationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CUSTOM_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraintCls: constraintClass,\n            constraints: constraintsOrValidationOptions instanceof Array ? constraintsOrValidationOptions as any[] : undefined,\n            validationOptions: !(constraintsOrValidationOptions instanceof Array) ? constraintsOrValidationOptions as ValidationOptions : maybeValidationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateIf(condition: (object: any, value: any) => boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.CONDITIONAL_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            constraints: [condition],\n            validationOptions: validationOptions\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateNested(validationOptions?: ValidationOptions): PropertyDecorator {\n    const opts: ValidationOptions = { ...validationOptions };\n    const eachPrefix = opts.each ? \"each value in \" : \"\";\n    opts.message = opts.message || eachPrefix + \"nested property $property must be either object or array\";\n\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.NESTED_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: opts,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { ValidationMetadataArgs } from \"../../metadata/ValidationMetadataArgs\";\nimport { ValidationTypes } from \"../../validation/ValidationTypes\";\nimport { ValidationMetadata } from \"../../metadata/ValidationMetadata\";\nimport { getMetadataStorage } from \"../../metadata/MetadataStorage\";\n\n/**\n * Resolve promise before validation\n */\nexport function ValidatePromise(validationOptions?: ValidationOptions): PropertyDecorator {\n    return function (object: Object, propertyName: string) {\n        const args: ValidationMetadataArgs = {\n            type: ValidationTypes.PROMISE_VALIDATION,\n            target: object.constructor,\n            propertyName: propertyName,\n            validationOptions: validationOptions,\n        };\n        getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n    };\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LATLONG = \"isLatLong\";\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function isLatLong(value: string): boolean {\n    return typeof value === \"string\" && validator.isLatLong(value);\n}\n\n/**\n * Checks if a value is string in format a \"latitude,longitude\".\n */\nexport function IsLatLong(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATLONG,\n            validator: {\n                validate: (value, args) => isLatLong(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude,longitude string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LATITUDE = \"isLatitude\";\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function isLatitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`${value},0`);\n}\n\n/**\n * Checks if a given value is a latitude.\n */\nexport function IsLatitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LATITUDE,\n            validator: {\n                validate: (value, args) => isLatitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a latitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"./ValidateBy\";\nimport { isLatLong } from \"./IsLatLong\";\n\nexport const IS_LONGITUDE = \"isLongitude\";\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function isLongitude(value: string): boolean {\n    return (typeof value === \"number\" || typeof value === \"string\") && isLatLong(`0,${value}`);\n}\n\n/**\n * Checks if a given value is a longitude.\n */\nexport function IsLongitude(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LONGITUDE,\n            validator: {\n                validate: (value, args) => isLongitude(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a longitude string or number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const EQUALS = \"equals\";\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function equals(value: unknown, comparison: unknown): boolean {\n    return value === comparison;\n}\n\n/**\n * Checks if value matches (\"===\") the comparison.\n */\nexport function Equals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => equals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const NOT_EQUALS = \"notEquals\";\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function notEquals(value: unknown, comparison: unknown): boolean {\n    return value !== comparison;\n}\n\n/**\n * Checks if value does not match (\"!==\") the comparison.\n */\nexport function NotEquals(comparison: any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_EQUALS,\n            constraints: [comparison],\n            validator: {\n                validate: (value, args) => notEquals(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be equal to $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_EMPTY = \"isEmpty\";\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function isEmpty(value: unknown): boolean {\n    return value === \"\" || value === null || value === undefined;\n}\n\n/**\n * Checks if given value is empty (=== '', === null, === undefined).\n */\nexport function IsEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMPTY,\n            validator: {\n                validate: (value, args) => isEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_EMPTY = \"isNotEmpty\";\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function isNotEmpty(value: unknown): boolean {\n    return value !== \"\" && value !== null && value !== undefined;\n}\n\n/**\n * Checks if given value is not empty (!== '', !== null, !== undefined).\n */\nexport function IsNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => isNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_IN = \"isIn\";\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function isIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value is in a array of allowed values.\n */\nexport function IsIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NOT_IN = \"isNotIn\";\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function isNotIn(value: unknown, possibleValues: unknown[]): boolean {\n    return !(possibleValues instanceof Array) || !possibleValues.some(possibleValue => possibleValue === value);\n}\n\n/**\n * Checks if given value not in a array of allowed values.\n */\nexport function IsNotIn(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_IN,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => isNotIn(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be one of the following values: $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DIVISIBLE_BY = \"isDivisibleBy\";\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function isDivisibleBy(value: unknown, num: number): boolean {\n    return typeof value === \"number\" &&\n        typeof num === \"number\" &&\n        validator.isDivisibleBy(String(value), num);\n}\n\n/**\n * Checks if value is a number that's divisible by another.\n */\nexport function IsDivisibleBy(num: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DIVISIBLE_BY,\n            constraints: [num],\n            validator: {\n                validate: (value, args) => isDivisibleBy(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be divisible by $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_POSITIVE = \"isPositive\";\n\n/**\n * Checks if the value is a positive number.\n */\nexport function isPositive(value: unknown): boolean {\n    return typeof value === \"number\" && value > 0;\n}\n\n/**\n * Checks if the value is a positive number.\n */\nexport function IsPositive(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSITIVE,\n            validator: {\n                validate: (value, args) => isPositive(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a positive number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NEGATIVE = \"isNegative\";\n\n/**\n * Checks if the value is a negative number.\n */\nexport function isNegative(value: unknown): boolean {\n    return typeof value === \"number\" && value < 0;\n}\n\n/**\n * Checks if the value is a negative number.\n */\nexport function IsNegative(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NEGATIVE,\n            validator: {\n                validate: (value, args) => isNegative(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a negative number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX = \"max\";\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function max(num: unknown, max: number): boolean {\n    return typeof num === \"number\" && typeof max === \"number\" && num <= max;\n}\n\n/**\n * Checks if the first number is less than or equal to the second.\n */\nexport function Max(maxValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX,\n            constraints: [maxValue],\n            validator: {\n                validate: (value, args) => max(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be greater than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN = \"min\";\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function min(num: unknown, min: number): boolean {\n    return typeof num === \"number\" && typeof min === \"number\" && num >= min;\n}\n\n/**\n * Checks if the first number is greater than or equal to the second.\n */\nexport function Min(minValue: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN,\n            constraints: [minValue],\n            validator: {\n                validate: (value, args) => min(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must not be less than $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MIN_DATE = \"minDate\";\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function minDate(date: unknown, minDate: Date): boolean {\n    return date instanceof Date && date.getTime() >= minDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MinDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => minDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"minimal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const MAX_DATE = \"maxDate\";\n\n /**\n * Checks if the value is a date that's before the specified date.\n */\nexport function maxDate(date: unknown, maxDate: Date): boolean {\n    return date instanceof Date && date.getTime() <= maxDate.getTime();\n}\n\n/**\n * Checks if the value is a date that's after the specified date.\n */\nexport function MaxDate(date: Date, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_DATE,\n            constraints: [date],\n            validator: {\n                validate: (value, args) => maxDate(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => \"maximal allowed date for \" + eachPrefix + \"$property is $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const CONTAINS = \"contains\";\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function contains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && validator.contains(value, seed);\n}\n\n/**\n * Checks if the string contains the seed.\n * If given value is not a string, then it returns false.\n */\nexport function Contains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => contains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const NOT_CONTAINS = \"notContains\";\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function notContains(value: unknown, seed: string): boolean {\n    return typeof value === \"string\" && !validator.contains(value, seed);\n}\n\n/**\n * Checks if the string does not contain the seed.\n * If given value is not a string, then it returns false.\n */\nexport function NotContains(seed: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: NOT_CONTAINS,\n            constraints: [seed],\n            validator: {\n                validate: (value, args) => notContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain a $constraint1 string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHA = \"isAlpha\";\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function isAlpha(value: unknown, locale?: ValidatorJS.AlphaLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlpha(value, locale);\n}\n\n/**\n * Checks if the string contains only letters (a-zA-Z).\n * If given value is not a string, then it returns false.\n */\nexport function IsAlpha(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHA,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlpha(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters (a-zA-Z)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ALPHANUMERIC = \"isAlphanumeric\";\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function isAlphanumeric(value: unknown, locale?: ValidatorJS.AlphanumericLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isAlphanumeric(value, locale);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsAlphanumeric(locale?: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ALPHANUMERIC,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isAlphanumeric(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only letters and numbers\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_DECIMAL = \"isDecimal\";\n\n/**\n * Checks if the string is a valid decimal.\n * If given value is not a string, then it returns false.\n */\nexport function isDecimal(value: unknown, options?: ValidatorJS.IsDecimalOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isDecimal(value, options);\n}\n\n/**\n * Checks if the string contains only letters and numbers.\n * If given value is not a string, then it returns false.\n */\nexport function IsDecimal(options?: ValidatorJS.IsDecimalOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DECIMAL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isDecimal(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property is not a valid decimal number.\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ASCII = \"isAscii\";\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function isAscii(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isAscii(value);\n}\n\n/**\n * Checks if the string contains ASCII chars only.\n * If given value is not a string, then it returns false.\n */\nexport function IsAscii(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ASCII,\n            validator: {\n                validate: (value, args) => isAscii(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain only ASCII characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE64 = \"isBase64\";\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase64(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase64(value);\n}\n\n/**\n * Checks if a string is base64 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase64(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE64,\n            validator: {\n                validate: (value, args) => isBase64(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base64 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BYTE_LENGTH = \"isByteLength\";\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function isByteLength(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isByteLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length (in bytes) falls in a range.\n * If given value is not a string, then it returns false.\n */\nexport function IsByteLength(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BYTE_LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => isByteLength(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property's byte length must fall into ($constraint1, $constraint2) range\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_CREDIT_CARD = \"isCreditCard\";\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function isCreditCard(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isCreditCard(value);\n}\n\n/**\n * Checks if the string is a credit card.\n * If given value is not a string, then it returns false.\n */\nexport function IsCreditCard(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CREDIT_CARD,\n            validator: {\n                validate: (value, args) => isCreditCard(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a credit card\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_CURRENCY = \"isCurrency\";\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function isCurrency(value: unknown, options?: ValidatorJS.IsCurrencyOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isCurrency(value, options);\n}\n\n/**\n * Checks if the string is a valid currency amount.\n * If given value is not a string, then it returns false.\n */\nexport function IsCurrency(options?: ValidatorJS.IsCurrencyOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_CURRENCY,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isCurrency(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a currency\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_EMAIL = \"isEmail\";\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function isEmail(value: unknown, options?: ValidatorJS.IsEmailOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isEmail(value, options);\n}\n\n/**\n * Checks if the string is an email.\n * If given value is not a string, then it returns false.\n */\nexport function IsEmail(options?: ValidatorJS.IsEmailOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EMAIL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isEmail(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an email\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_FQDN = \"isFqdn\";\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function isFQDN(value: unknown, options?: ValidatorJS.IsFQDNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isFQDN(value, options);\n}\n\n/**\n * Checks if the string is a fully qualified domain name (e.g. domain.com).\n * If given value is not a string, then it returns false.\n */\nexport function IsFQDN(options?: ValidatorJS.IsFQDNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FQDN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isFQDN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid domain name\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_FULL_WIDTH = \"isFullWidth\";\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isFullWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isFullWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsFullWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FULL_WIDTH,\n            validator: {\n                validate: (value, args) => isFullWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HALF_WIDTH = \"isHalfWidth\";\n\n/**\n * Checks if the string contains any half-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isHalfWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHalfWidth(value);\n}\n\n/**\n * Checks if the string contains any full-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsHalfWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HALF_WIDTH,\n            validator: {\n                validate: (value, args) => isHalfWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_VARIABLE_WIDTH = \"isVariableWidth\";\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function isVariableWidth(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isVariableWidth(value);\n}\n\n/**\n * Checks if the string contains variable-width chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsVariableWidth(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_VARIABLE_WIDTH,\n            validator: {\n                validate: (value, args) => isVariableWidth(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain a full-width and half-width characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEX_COLOR = \"isHexColor\";\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function isHexColor(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexColor(value);\n}\n\n/**\n * Checks if the string is a hexadecimal color.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexColor(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEX_COLOR,\n            validator: {\n                validate: (value, args) => isHexColor(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HEXADECIMAL = \"isHexadecimal\";\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function isHexadecimal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHexadecimal(value);\n}\n\n/**\n * Checks if the string is a hexadecimal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsHexadecimal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HEXADECIMAL,\n            validator: {\n                validate: (value, args) => isHexadecimal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hexadecimal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationArguments } from \"../validation/ValidationArguments\";\n\n/**\n * Options used to pass to validation decorators.\n */\nexport interface ValidationOptions {\n\n    /**\n     * Specifies if validated value is an array and each of its items must be validated.\n     */\n    each?: boolean;\n\n    /**\n     * Error message to be used on validation fail.\n     * Message can be either string or a function that returns a string.\n     */\n    message?: string | ((validationArguments: ValidationArguments) => string);\n\n    /**\n     * Validation groups used for this validation.\n     */\n    groups?: string[];\n\n    /**\n     * Indicates if validation must be performed always, no matter of validation groups used.\n     */\n    always?: boolean;\n\n    /*\n     * A transient set of data passed through to the validation result for response mapping\n     */\n    context?: any;\n}\n\n\nexport function isValidationOptions(val: any): val is ValidationOptions {\n    if (!val) {\n        return false;\n    }\n    return \"each\" in val\n        || \"message\" in val\n        || \"groups\" in val\n        || \"always\" in val\n        || \"context\" in val;\n}\n","import { ValidationOptions, isValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_MAC_ADDRESS = \"isMacAddress\";\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function isMACAddress(value: unknown, options?: ValidatorJS.IsMACAddressOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isMACAddress(value, options);\n}\n\n/**\n * Check if the string is a MAC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsMACAddress(optionsArg?: ValidatorJS.IsMACAddressOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(validationOptionsArg?: ValidationOptions): PropertyDecorator;\nexport function IsMACAddress(optionsOrValidationOptionsArg?: ValidatorJS.IsMACAddressOptions | ValidationOptions, validationOptionsArg?: ValidationOptions): PropertyDecorator {\n    const options = !isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : undefined;\n    const validationOptions = isValidationOptions(optionsOrValidationOptionsArg) ? optionsOrValidationOptionsArg : validationOptionsArg;\n\n    return ValidateBy(\n        {\n            name: IS_MAC_ADDRESS,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isMACAddress(value, options),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a MAC Address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsIpVersion = \"4\" | \"6\" | 4 | 6;\n\nexport const IS_IP = \"isIp\";\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function isIP(value: unknown, version?: IsIpVersion): boolean {\n    const versionStr = version ? (`${version}` as \"4\" | \"6\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isIP(value, versionStr);\n}\n\n/**\n * Checks if the string is an IP (version 4 or 6).\n * If given value is not a string, then it returns false.\n */\nexport function IsIP(version?: IsIpVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IP,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isIP(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ip address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PORT = \"isPort\";\n\n/**\n * Check if the string is a valid port number.\n */\nexport function isPort(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isPort(value);\n}\n\n/**\n * Check if the string is a valid port number.\n */\nexport function IsPort(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PORT,\n            validator: {\n                validate: (value, args) => isPort(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a port\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport type IsISBNVersion = \"10\" | \"13\" | 10 | 13;\n\nexport const IS_ISBN = \"isIsbn\";\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function isISBN(value: unknown, version?: IsISBNVersion): boolean {\n    const versionStr = version ? (`${version}` as \"10\" | \"13\") : undefined;\n    return typeof value === \"string\" && ValidatorJS.isISBN(value, versionStr);\n}\n\n/**\n * Checks if the string is an ISBN (version 10 or 13).\n * If given value is not a string, then it returns false.\n */\nexport function IsISBN(version?: IsISBNVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISBN,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isISBN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISBN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISIN = \"isIsin\";\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function isISIN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISIN(value);\n}\n\n/**\n * Checks if the string is an ISIN (stock/security identifier).\n * If given value is not a string, then it returns false.\n */\nexport function IsISIN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISIN,\n            validator: {\n                validate: (value, args) => isISIN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISIN (stock/security identifier)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISO8601 = \"isIso8601\";\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function isISO8601(value: unknown, options?: ValidatorJS.IsISO8601Options): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISO8601(value, options);\n}\n\n/**\n * Checks if the string is a valid ISO 8601 date.\n * If given value is not a string, then it returns false.\n * Use the option strict = true for additional checks for a valid date, e.g. invalidates dates like 2019-02-29.\n */\nexport function IsISO8601(options?: ValidatorJS.IsISO8601Options, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO8601,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISO8601(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO 8601 date string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JSON = \"isJson\";\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function isJSON(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJSON(value);\n}\n\n/**\n * Checks if the string is valid JSON (note: uses JSON.parse).\n * If given value is not a string, then it returns false.\n */\nexport function IsJSON(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JSON,\n            validator: {\n                validate: (value, args) => isJSON(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a json string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_JWT = \"isJwt\";\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function isJWT(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isJWT(value);\n}\n\n/**\n * Checks if the string is valid JWT token.\n * If given value is not a string, then it returns false.\n */\nexport function IsJWT(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_JWT,\n            validator: {\n                validate: (value, args) => isJWT(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a jwt string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOWERCASE = \"isLowercase\";\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function isLowercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLowercase(value);\n}\n\n/**\n * Checks if the string is lowercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsLowercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOWERCASE,\n            validator: {\n                validate: (value, args) => isLowercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a lowercase string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MOBILE_PHONE = \"isMobilePhone\";\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function isMobilePhone(value: unknown, locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions): boolean {\n    return typeof value === \"string\" && validator.isMobilePhone(value, locale, options);\n}\n\n/**\n * Checks if the string is a mobile phone number (locale is either an array of locales (e.g ['sk-SK', 'sr-RS'])\n * OR one of ['am-Am', 'ar-AE', 'ar-BH', 'ar-DZ', 'ar-EG', 'ar-IQ', ar-JO', 'ar-KW', 'ar-SA', 'ar-SY', 'ar-TN', 'be-BY',\n * 'bg-BG', 'bn-BD', 'cs-CZ', 'da-DK', 'de-DE', 'de-AT', 'el-GR', 'en-AU', 'en-CA', 'en-GB', 'en-GG', 'en-GH', 'en-HK',\n * 'en-MO', 'en-IE', 'en-IN', 'en-KE', 'en-MT', 'en-MU', 'en-NG', 'en-NZ', 'en-PK', 'en-RW', 'en-SG', 'en-SL', 'en-UG',\n * 'en-US', 'en-TZ', 'en-ZA', 'en-ZM', 'es-CL', 'es-CR', 'es-EC', 'es-ES', 'es-MX', 'es-PA', 'es-PY', 'es-UY', 'et-EE',\n * 'fa-IR', 'fi-FI', 'fj-FJ', 'fo-FO', 'fr-BE', 'fr-FR', 'fr-GF', 'fr-GP', 'fr-MQ', 'fr-RE', 'he-IL', 'hu-HU', 'id-ID',\n * 'it-IT', 'ja-JP', 'kk-KZ', 'kl-GL', 'ko-KR', 'lt-LT', 'ms-MY', 'nb-NO', 'ne-NP', 'nl-BE', 'nl-NL', 'nn-NO', 'pl-PL',\n * 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sl-SI', 'sk-SK', 'sr-RS', 'sv-SE', 'th-TH', 'tr-TR', 'uk-UA', 'vi-VN', 'zh-CN',\n * 'zh-HK', 'zh-MO', 'zh-TW']\n * If given value is not a string, then it returns false.\n */\nexport function IsMobilePhone(locale?: validator.MobilePhoneLocale, options?: validator.IsMobilePhoneOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MOBILE_PHONE,\n            constraints: [locale, options],\n            validator: {\n                validate: (value, args) => isMobilePhone(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a phone number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_2 = \"isISO31661Alpha2\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function isISO31661Alpha2(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha2(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) officially assigned country code.\n */\nexport function IsISO31661Alpha2(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_2,\n            validator: {\n                validate: (value, args) => isISO31661Alpha2(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha2 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISO31661_ALPHA_3 = \"isISO31661Alpha3\";\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function isISO31661Alpha3(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISO31661Alpha3(value);\n}\n\n/**\n * Check if the string is a valid [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) officially assigned country code.\n */\nexport function IsISO31661Alpha3(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISO31661_ALPHA_3,\n            validator: {\n                validate: (value, args) => isISO31661Alpha3(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid ISO31661 Alpha3 code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MONGO_ID = \"isMongoId\";\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function isMongoId(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMongoId(value);\n}\n\n/**\n * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.\n * If given value is not a string, then it returns false.\n */\nexport function IsMongoId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MONGO_ID,\n            validator: {\n                validate: (value, args) => isMongoId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a mongodb id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MULTIBYTE = \"isMultibyte\";\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function isMultibyte(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMultibyte(value);\n}\n\n/**\n * Checks if the string contains one or more multibyte chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsMultibyte(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MULTIBYTE,\n            validator: {\n                validate: (value, args) => isMultibyte(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain one or more multibyte chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SURROGATE_PAIR = \"isSurrogatePair\";\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function isSurrogatePair(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSurrogatePair(value);\n}\n\n/**\n * Checks if the string contains any surrogate pairs chars.\n * If given value is not a string, then it returns false.\n */\nexport function IsSurrogatePair(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SURROGATE_PAIR,\n            validator: {\n                validate: (value, args) => isSurrogatePair(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain any surrogate pairs chars\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_URL = \"isUrl\";\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function isURL(value: string, options?: ValidatorJS.IsURLOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isURL(value, options);\n}\n\n/**\n * Checks if the string is an url.\n * If given value is not a string, then it returns false.\n */\nexport function IsUrl(options?: ValidatorJS.IsURLOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_URL,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isURL(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an URL address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport type UUIDVersion = \"3\" | \"4\" | \"5\" | \"all\" | 3 | 4 | 5;\n\nexport const IS_UUID = \"isUuid\";\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function isUUID(value: unknown, version?: UUIDVersion): boolean {\n    return typeof value === \"string\" && validator.isUUID(value, version);\n}\n\n/**\n * Checks if the string is a UUID (version 3, 4 or 5).\n * If given value is not a string, then it returns false.\n */\nexport function IsUUID(version?: UUIDVersion, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UUID,\n            constraints: [version],\n            validator: {\n                validate: (value, args) => isUUID(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an UUID\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_FIREBASE_PUSH_ID = \"IsFirebasePushId\";\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function isFirebasePushId(value: unknown): boolean {\n    const webSafeRegex = /^[a-zA-Z0-9_-]*$/;\n    return typeof value === \"string\" && value.length === 20 && webSafeRegex.test(value);\n}\n\n/**\n * Checks if the string is a Firebase Push Id\n * If given value is not a Firebase Push Id, it returns false\n */\nexport function IsFirebasePushId(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_FIREBASE_PUSH_ID,\n            validator: {\n                validate: (value, args) => isFirebasePushId(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Firebase Push Id\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_UPPERCASE = \"isUppercase\";\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function isUppercase(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isUppercase(value);\n}\n\n/**\n * Checks if the string is uppercase.\n * If given value is not a string, then it returns false.\n */\nexport function IsUppercase(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_UPPERCASE,\n            validator: {\n                validate: (value, args) => isUppercase(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be uppercase\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const LENGTH = \"length\";\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function length(value: unknown, min: number, max?: number): boolean {\n    return typeof value === \"string\" && validator.isLength(value, { min, max });\n}\n\n/**\n * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function Length(min: number, max?: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: LENGTH,\n            constraints: [min, max],\n            validator: {\n                validate: (value, args) => length(value, args.constraints[0], args.constraints[1]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        const isMinLength = args.constraints[0] !== null && args.constraints[0] !== undefined;\n                        const isMaxLength = args.constraints[1] !== null && args.constraints[1] !== undefined;\n                        if (isMinLength && (!args.value || args.value.length < args.constraints[0])) {\n                            return eachPrefix + \"$property must be longer than or equal to $constraint1 characters\";\n                        } else if (isMaxLength && (args.value.length > args.constraints[1])) {\n                            return eachPrefix + \"$property must be shorter than or equal to $constraint2 characters\";\n                        }\n                        return eachPrefix + \"$property must be longer than or equal to $constraint1 and shorter than or equal to $constraint2 characters\";\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MAX_LENGTH = \"maxLength\";\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function maxLength(value: unknown, max: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min: 0, max });\n}\n\n/**\n * Checks if the string's length is not more than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MaxLength(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MAX_LENGTH,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => maxLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be shorter than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MIN_LENGTH = \"minLength\";\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function minLength(value: unknown, min: number) {\n    return typeof value === \"string\" && validator.isLength(value, { min });\n}\n\n/**\n * Checks if the string's length is not less than given number. Note: this function takes into account surrogate pairs.\n * If given value is not a string, then it returns false.\n */\nexport function MinLength(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: MIN_LENGTH,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => minLength(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be longer than or equal to $constraint1 characters\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const MATCHES = \"matches\";\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i).\n * If given value is not a string, then it returns false.\n */\nexport function matches(value: string, pattern: RegExp): boolean;\nexport function matches(value: string, pattern: string, modifiers: string): boolean;\nexport function matches(value: string, pattern: RegExp | string, modifiers?: string): boolean {\n    return typeof value === \"string\" && validator.matches(value, pattern as unknown as any, modifiers);\n}\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i)\n * If given value is not a string, then it returns false.\n */\nexport function Matches(pattern: RegExp, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: string, modifiers?: string, validationOptions?: ValidationOptions): PropertyDecorator;\nexport function Matches(pattern: RegExp | string, modifiersOrAnnotationOptions?: string | ValidationOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    let modifiers: string;\n    if (modifiersOrAnnotationOptions && modifiersOrAnnotationOptions instanceof Object && !validationOptions) {\n        validationOptions = modifiersOrAnnotationOptions as ValidationOptions;\n    } else {\n        modifiers = modifiersOrAnnotationOptions as string;\n    }\n\n    return ValidateBy(\n        {\n            name: MATCHES,\n            constraints: [pattern, modifiers],\n            validator: {\n                validate: (value, args) => matches(value, args.constraints[0], args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => eachPrefix + \"$property must match $constraint1 regular expression\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { PhoneNumberUtil } from \"google-libphonenumber\";\n\nexport const IS_PHONE_NUMBER = \"isPhoneNumber\";\n\n/**\n * Checks if the string is a valid phone number.\n * @param value the potential phone number string to test\n * @param {string} region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function isPhoneNumber(value: string, region: string | null): boolean {\n    const phoneUtil = PhoneNumberUtil.getInstance();\n    try {\n        const phoneNum = phoneUtil.parseAndKeepRawInput(value, region);\n        const result = phoneUtil.isValidNumber(phoneNum);\n        return result;\n    } catch (error) {\n        // logging?\n        return false;\n    }\n}\n\n/**\n * Checks if the string is a valid phone number.\n * @param region 2 characters uppercase country code (e.g. DE, US, CH).\n * If users must enter the intl. prefix (e.g. +41), then you may pass \"ZZ\" or null as region.\n * See [google-libphonenumber, metadata.js:countryCodeToRegionCodeMap on github]{@link https://github.com/ruimarinho/google-libphonenumber/blob/1e46138878cff479aafe2ce62175c6c49cb58720/src/metadata.js#L33}\n */\nexport function IsPhoneNumber(region: string | null, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PHONE_NUMBER,\n            constraints: [region],\n            validator: {\n                validate: (value, args) => isPhoneNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid phone number\",\n                    validationOptions\n                ),\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MILITARY_TIME = \"isMilitaryTime\";\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function isMilitaryTime(value: unknown): boolean {\n    const militaryTimeRegex = /^([01]\\d|2[0-3]):?([0-5]\\d)$/;\n    return typeof value === \"string\" && validator.matches(value, militaryTimeRegex);\n}\n\n/**\n * Checks if the string represents a time without a given timezone in the format HH:MM (military)\n * If the given value does not match the pattern HH:MM, then it returns false.\n */\nexport function IsMilitaryTime(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MILITARY_TIME,\n            validator: {\n                validate: (value, args) => isMilitaryTime(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid representation of military time in the format HH:MM\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_HASH = \"isHash\";\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function isHash(value: unknown, algorithm: ValidatorJS.HashAlgorithm): boolean {\n    return typeof value === \"string\" && ValidatorJS.isHash(value, algorithm);\n}\n\n/**\n * Check if the string is a hash of type algorithm.\n * Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128',\n * 'tiger160', 'tiger192', 'crc32', 'crc32b']\n */\nexport function IsHash(algorithm: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HASH,\n            constraints: [algorithm],\n            validator: {\n                validate: (value, args) => isHash(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a hash of type $constraint1\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_ISSN = \"isISSN\";\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function isISSN(value: unknown, options?: ValidatorJS.IsISSNOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isISSN(value, options);\n}\n\n/**\n * Checks if the string is a ISSN.\n * If given value is not a string, then it returns false.\n */\nexport function IsISSN(options?: ValidatorJS.IsISSNOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISSN,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isISSN(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISSN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE_STRING = \"isDateString\";\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function isDateString(value: unknown): boolean {\n    const regex = /^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:Z|[\\+\\-][0-2]\\d(?:\\:[0-5]\\d)?)?$/g;\n    return typeof value === \"string\" && regex.test(value);\n}\n\n/**\n * Checks if a given value is a ISOString date.\n */\nexport function IsDateString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE_STRING,\n            validator: {\n                validate: (value, args) => isDateString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a ISOString\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BOOLEAN_STRING = \"isBooleanString\";\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function isBooleanString(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBoolean(value);\n}\n\n/**\n * Checks if a string is a boolean.\n * If given value is not a string, then it returns false.\n */\nexport function IsBooleanString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN_STRING,\n            validator: {\n                validate: (value, args) => isBooleanString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_NUMBER_STRING = \"isNumberString\";\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function isNumberString(value: unknown, options?: ValidatorJS.IsNumericOptions): boolean {\n    return typeof value === \"string\" && ValidatorJS.isNumeric(value, options);\n}\n\n/**\n * Checks if the string is numeric.\n * If given value is not a string, then it returns false.\n */\nexport function IsNumberString(options?: ValidatorJS.IsNumericOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER_STRING,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumberString(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BASE32 = \"isBase32\";\n\n/**\n * Checks if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function isBase32(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBase32(value);\n}\n\n/**\n * Check if a string is base32 encoded.\n * If given value is not a string, then it returns false.\n */\nexport function IsBase32(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BASE32,\n            validator: {\n                validate: (value, args) => isBase32(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be base32 encoded\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BIC = \"isBIC\";\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function isBIC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBIC(value);\n}\n\n/**\n * Check if a string is a BIC (Bank Identification Code) or SWIFT code.\n * If given value is not a string, then it returns false.\n */\nexport function IsBIC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BIC,\n            validator: {\n                validate: (value, args) => isBIC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BIC or SWIFT code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_BTC_ADDRESS = \"isBtcAddress\";\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function isBtcAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isBtcAddress(value);\n}\n\n/**\n * Check if the string is a valid BTC address.\n * If given value is not a string, then it returns false.\n */\nexport function IsBtcAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BTC_ADDRESS,\n            validator: {\n                validate: (value, args) => isBtcAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a BTC address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_DATA_URI = \"isDataURI\";\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isDataURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isDataURI(value);\n}\n\n/**\n * Check if the string is a data uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsDataURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATA_URI,\n            validator: {\n                validate: (value, args) => isDataURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a data uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_EAN = \"isEAN\";\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function isEAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEAN(value);\n}\n\n/**\n * Check if the string is an EAN (European Article Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsEAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_EAN,\n            validator: {\n                validate: (value, args) => isEAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an EAN (European Article Number)\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ETHEREUM_ADDRESS = \"isEthereumAddress\";\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function isEthereumAddress(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isEthereumAddress(value);\n}\n\n/**\n * Check if the string is an Ethereum address using basic regex. Does not validate address checksums.\n * If given value is not a string, then it returns false.\n */\nexport function IsEthereumAddress(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ETHEREUM_ADDRESS,\n            validator: {\n                validate: (value, args) => isEthereumAddress(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an Ethereum address\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_HSL = \"isHSL\";\n\n/**\n* Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function isHSL(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isHSL(value);\n}\n\n/**\n * Check if the string is an HSL (hue, saturation, lightness, optional alpha) color based on CSS Colors Level 4 specification.\n * Comma-separated format supported. Space-separated format supported with the exception of a few edge cases (ex: hsl(200grad+.1%62%/1)).\n * If given value is not a string, then it returns false.\n */\nexport function IsHSL(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_HSL,\n            validator: {\n                validate: (value, args) => isHSL(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a HSL color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_IBAN = \"isIBAN\";\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function isIBAN(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isIBAN(value);\n}\n\n/**\n * Check if a string is a IBAN (International Bank Account Number).\n * If given value is not a string, then it returns false.\n */\nexport function IsIBAN(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IBAN,\n            validator: {\n                validate: (value, args) => isIBAN(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an IBAN\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport ValidatorJS from \"validator\";\n\nexport const IS_IDENTITY_CARD = \"isIdentityCard\";\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function isIdentityCard(value: unknown, locale: ValidatorJS.IdentityCardLocale): boolean {\n    return typeof value === \"string\" && ValidatorJS.isIdentityCard(value, locale);\n}\n\n/**\n * Check if the string is a valid identity card code.\n * locale is one of ['ES', 'zh-TW', 'he-IL', 'ar-TN'] OR 'any'. If 'any' is used, function will check if any of the locals match.\n * Defaults to 'any'.\n * If given value is not a string, then it returns false.\n */\nexport function IsIdentityCard(locale?: ValidatorJS.IdentityCardLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_IDENTITY_CARD,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isIdentityCard(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a identity card number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_ISRC = \"isISRC\";\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function isISRC(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isISRC(value);\n}\n\n/**\n * Check if the string is a ISRC.\n * If given value is not a string, then it returns false.\n */\nexport function IsISRC(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ISRC,\n            validator: {\n                validate: (value, args) => isISRC(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an ISRC\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_LOCALE = \"isLocale\";\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function isLocale(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isLocale(value);\n}\n\n/**\n * Check if the string is a locale.\n * If given value is not a string, then it returns false.\n */\nexport function IsLocale(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_LOCALE,\n            validator: {\n                validate: (value, args) => isLocale(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be locale\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MAGNET_URI = \"isMagnetURI\";\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function isMagnetURI(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMagnetURI(value);\n}\n\n/**\n * Check if the string is a magnet uri format.\n * If given value is not a string, then it returns false.\n */\nexport function IsMagnetURI(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MAGNET_URI,\n            validator: {\n                validate: (value, args) => isMagnetURI(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be magnet uri format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_MIME_TYPE = \"isMimeType\";\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function isMimeType(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isMimeType(value);\n}\n\n/**\n * Check if the string matches to a valid MIME type format\n * If given value is not a string, then it returns false.\n */\nexport function IsMimeType(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_MIME_TYPE,\n            validator: {\n                validate: (value, args) => isMimeType(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be MIME type format\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_OCTAL = \"isOctal\";\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function isOctal(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isOctal(value);\n}\n\n/**\n * Check if the string is a valid octal number.\n * If given value is not a string, then it returns false.\n */\nexport function IsOctal(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OCTAL,\n            validator: {\n                validate: (value, args) => isOctal(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid octal number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_PASSPORT_NUMBER = \"isPassportNumber\";\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function isPassportNumber(value: unknown, countryCode: string): boolean {\n    return typeof value === \"string\" && validator.isPassportNumber(value, countryCode);\n}\n\n/**\n * Check if the string is a valid passport number relative to a specific country code.\n * If given value is not a string, then it returns false.\n */\nexport function IsPassportNumber(countryCode: string, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_PASSPORT_NUMBER,\n            constraints: [countryCode],\n            validator: {\n                validate: (value, args) => isPassportNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be valid passport number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_POSTAL_CODE = \"isPostalCode\";\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function isPostalCode(value: unknown, locale: validator.PostalCodeLocale): boolean {\n    return typeof value === \"string\" && validator.isPostalCode(value, locale);\n}\n\n/**\n * Check if the string is a postal code,\n * (locale is one of [ 'AD', 'AT', 'AU', 'BE', 'BG', 'BR', 'CA', 'CH', 'CZ', 'DE', 'DK', 'DZ', 'EE', 'ES', 'FI', 'FR', 'GB', 'GR', 'HR', 'HU', 'ID', 'IE' 'IL', 'IN', 'IR', 'IS', 'IT', 'JP', 'KE', 'LI', 'LT', 'LU', 'LV', 'MT', 'MX', 'NL', 'NO', 'NZ', 'PL', 'PR', 'PT', 'RO', 'RU', 'SA', 'SE', 'SI', 'TN', 'TW', 'UA', 'US', 'ZA', 'ZM' ] OR 'any'. If 'any' is used, function will check if any of the locals match. Locale list is validator.isPostalCodeLocales.).\n * If given value is not a string, then it returns false.\n */\nexport function IsPostalCode(locale?: validator.PostalCodeLocale, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_POSTAL_CODE,\n            constraints: [locale],\n            validator: {\n                validate: (value, args) => isPostalCode(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a postal code\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RFC_3339 = \"isRFC3339\";\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function isRFC3339(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isRFC3339(value);\n}\n\n/**\n * Check if the string is a valid RFC 3339 date.\n * If given value is not a string, then it returns false.\n */\nexport function IsRFC3339(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RFC_3339,\n            validator: {\n                validate: (value, args) => isRFC3339(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RFC 3339 date\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_RGB_COLOR = \"isRgbColor\";\n\n/**\n* Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function isRgbColor(value: unknown, includePercentValues?: boolean): boolean {\n    return typeof value === \"string\" && validator.isRgbColor(value, includePercentValues);\n}\n\n/**\n * Check if the string is a rgb or rgba color.\n * `includePercentValues` defaults to true. If you don't want to allow to set rgb or rgba values with percents, like rgb(5%,5%,5%), or rgba(90%,90%,90%,.3), then set it to false.\n * If given value is not a string, then it returns false.\n */\nexport function IsRgbColor(includePercentValues?: boolean, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_RGB_COLOR,\n            constraints: [includePercentValues],\n            validator: {\n                validate: (value, args) => isRgbColor(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be RGB color\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport validator from \"validator\";\n\nexport const IS_SEM_VER = \"isSemVer\";\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function isSemVer(value: unknown): boolean {\n    return typeof value === \"string\" && validator.isSemVer(value);\n}\n\n/**\n * Check if the string is a Semantic Versioning Specification (SemVer).\n * If given value is not a string, then it returns false.\n */\nexport function IsSemVer(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_SEM_VER,\n            validator: {\n                validate: (value, args) => isSemVer(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Semantic Versioning Specification\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_BOOLEAN = \"isBoolean\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isBoolean(value: unknown): boolean {\n    return value instanceof Boolean || typeof value === \"boolean\";\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsBoolean(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_BOOLEAN,\n            validator: {\n                validate: (value, args) => isBoolean(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a boolean value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_DATE = \"isDate\";\n\n/**\n * Checks if a given value is a number.\n */\nexport function isDate(value: unknown): boolean {\n    return value instanceof Date && !isNaN(value.getTime());\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsDate(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_DATE,\n            validator: {\n                validate: (value, args) => isDate(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a Date instance\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_NUMBER = \"isNumber\";\n\n/**\n * Options to be passed to IsNumber decorator.\n */\nexport interface IsNumberOptions {\n    allowNaN?: boolean;\n    allowInfinity?: boolean;\n    maxDecimalPlaces?: number;\n}\n\n/**\n * Checks if a given value is a number.\n */\nexport function isNumber(value: unknown, options: IsNumberOptions = {}): boolean {\n    if (typeof value !== \"number\") {\n        return false;\n    }\n\n    if (value === Infinity || value === -Infinity) {\n        return options.allowInfinity;\n    }\n\n    if (Number.isNaN(value)) {\n        return options.allowNaN;\n    }\n\n    if (options.maxDecimalPlaces !== undefined) {\n        let decimalPlaces = 0;\n        if ((value % 1) !== 0) {\n            decimalPlaces = value.toString().split(\".\")[1].length;\n        }\n        if (decimalPlaces > options.maxDecimalPlaces) {\n            return false;\n        }\n    }\n\n    return Number.isFinite(value);\n}\n\n/**\n * Checks if a value is a number.\n */\nexport function IsNumber(options: IsNumberOptions = {}, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NUMBER,\n            constraints: [options],\n            validator: {\n                validate: (value, args) => isNumber(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a number conforming to the specified constraints\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ENUM = \"isEnum\";\n\n/**\n * Checks if a given value is an enum\n */\nexport function isEnum(value: unknown, entity: any): boolean {\n    const enumValues = Object.keys(entity)\n        .map(k => entity[k]);\n    return enumValues.indexOf(value) >= 0;\n}\n\n/**\n * Checks if a given value is an enum\n */\nexport function IsEnum(entity: Object, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ENUM,\n            constraints: [entity],\n            validator: {\n                validate: (value, args) => isEnum(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a valid enum value\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INT = \"isInt\";\n\n/**\n * Checks if value is an integer.\n */\nexport function isInt(val: unknown): boolean {\n    return typeof val === \"number\" && Number.isInteger(val);\n}\n\n/**\n * Checks if value is an integer.\n */\nexport function IsInt(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INT,\n            validator: {\n                validate: (value, args) => isInt(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an integer number\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_STRING = \"isString\";\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function isString(value: unknown): value is string {\n   return value instanceof String || typeof value === \"string\";\n}\n\n/**\n* Checks if a given value is a real string.\n*/\nexport function IsString(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_STRING,\n            validator: {\n                validate: (value, args) => isString(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a string\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_ARRAY = \"isArray\";\n\n/**\n * Checks if a given value is an array\n */\nexport function isArray(value: unknown): boolean {\n    return value instanceof Array;\n}\n\n/**\n * Checks if a given value is an array\n */\nexport function IsArray(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_ARRAY,\n            validator: {\n                validate: (value, args) => isArray(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an array\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_OBJECT = \"isObject\";\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function isObject(value: unknown): value is object {\n    return value != null && (typeof value === \"object\" || typeof value === \"function\") && !Array.isArray(value);\n}\n\n/**\n * Checks if the value is valid Object.\n * Returns false if the value is not an object.\n */\nexport function IsObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_OBJECT,\n            validator: {\n                validate: (value, args) => isObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be an object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_CONTAINS = \"arrayContains\";\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) !== -1);\n}\n\n/**\n * Checks if array contains all values from the given array of values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_CONTAINS = \"arrayNotContains\";\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotContains(array: unknown, values: any[]) {\n    if (!(array instanceof Array))\n        return false;\n\n    return values.every(value => array.indexOf(value) === -1);\n}\n\n/**\n * Checks if array does not contain any of the given values.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotContains(values: any[], validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_CONTAINS,\n            constraints: [values],\n            validator: {\n                validate: (value, args) => arrayNotContains(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not contain $constraint1 values\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_NOT_EMPTY = \"arrayNotEmpty\";\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayNotEmpty(array: unknown) {\n    return array instanceof Array && array.length > 0;\n}\n\n/**\n * Checks if given array is not empty.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayNotEmpty(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_NOT_EMPTY,\n            validator: {\n                validate: (value, args) => arrayNotEmpty(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property should not be empty\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MIN_SIZE = \"arrayMinSize\";\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMinSize(array: unknown, min: number) {\n    return array instanceof Array && array.length >= min;\n}\n\n/**\n * Checks if array's length is as minimal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMinSize(min: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MIN_SIZE,\n            constraints: [min],\n            validator: {\n                validate: (value, args) => arrayMinSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain at least $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_MAX_SIZE = \"arrayMaxSize\";\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayMaxSize(array: unknown, max: number) {\n    return array instanceof Array && array.length <= max;\n}\n\n/**\n * Checks if array's length is as maximal this number.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayMaxSize(max: number, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_MAX_SIZE,\n            constraints: [max],\n            validator: {\n                validate: (value, args) => arrayMaxSize(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must contain not more than $constraint1 elements\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const ARRAY_UNIQUE = \"arrayUnique\";\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function arrayUnique(array: unknown) {\n    if (!(array instanceof Array))\n        return false;\n\n    const uniqueItems = array.filter((a, b, c) => c.indexOf(a) === b);\n    return array.length === uniqueItems.length;\n}\n\n/**\n * Checks if all array's values are unique. Comparison for objects is reference-based.\n * If null or undefined is given then this function returns false.\n */\nexport function ArrayUnique(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: ARRAY_UNIQUE,\n            validator: {\n                validate: (value, args) => arrayUnique(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"All $property's elements must be unique\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\nimport { isObject } from \"../typechecker/IsObject\";\n\nexport const IS_NOT_EMPTY_OBJECT = \"isNotEmptyObject\";\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function isNotEmptyObject(value: unknown): boolean {\n    if (!isObject(value)) {\n        return false;\n    }\n    for (const key in value) {\n        if (value.hasOwnProperty(key)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks if the value is valid Object & not empty.\n * Returns false if the value is not an object or an empty valid object.\n */\nexport function IsNotEmptyObject(validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_NOT_EMPTY_OBJECT,\n            validator: {\n                validate: (value, args) => isNotEmptyObject(value),\n                defaultMessage: buildMessage(\n                    (eachPrefix) => eachPrefix + \"$property must be a non-empty object\",\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import { ValidationOptions } from \"../ValidationOptions\";\nimport { buildMessage, ValidateBy } from \"../common/ValidateBy\";\n\nexport const IS_INSTANCE = \"isInstance\";\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function isInstance(object: unknown, targetTypeConstructor: new (...args: any[]) => any) {\n    return targetTypeConstructor\n        && typeof targetTypeConstructor === \"function\"\n        && object instanceof targetTypeConstructor;\n}\n\n/**\n * Checks if the value is an instance of the specified object.\n */\nexport function IsInstance(targetType: new (...args: any[]) => any, validationOptions?: ValidationOptions): PropertyDecorator {\n    return ValidateBy(\n        {\n            name: IS_INSTANCE,\n            constraints: [targetType],\n            validator: {\n                validate: (value, args) => isInstance(value, args.constraints[0]),\n                defaultMessage: buildMessage(\n                    (eachPrefix, args) => {\n                        if (args.constraints[0]) {\n                            return eachPrefix + `$property must be an instance of ${args.constraints[0].name}`;\n                        } else {\n                            return eachPrefix + `${IS_INSTANCE} decorator expects and object as value, but got falsy value.`;\n                        }\n                    },\n                    validationOptions\n                )\n            }\n        },\n        validationOptions\n    );\n}\n","import {ValidationError} from \"./validation/ValidationError\";\nimport {ValidatorOptions} from \"./validation/ValidatorOptions\";\nimport {ValidationSchema} from \"./validation-schema/ValidationSchema\";\nimport {getMetadataStorage} from \"./metadata/MetadataStorage\";\nimport {Validator} from \"./validation/Validator\";\nimport {getFromContainer} from \"./container\";\n\n// -------------------------------------------------------------------------\n// Export everything api users needs\n// -------------------------------------------------------------------------\n\nexport * from \"./container\";\nexport * from \"./decorator/decorators\";\nexport * from \"./decorator/ValidationOptions\";\nexport * from \"./validation/ValidatorConstraintInterface\";\nexport * from \"./validation/ValidationError\";\nexport * from \"./validation/ValidatorOptions\";\nexport * from \"./validation/ValidationArguments\";\nexport * from \"./validation/ValidationTypes\";\nexport * from \"./validation/Validator\";\nexport * from \"./validation-schema/ValidationSchema\";\nexport * from \"./register-decorator\";\nexport * from \"./metadata/MetadataStorage\";\n\n// -------------------------------------------------------------------------\n// Shortcut methods for api users\n// -------------------------------------------------------------------------\n\n/**\n * Validates given object.\n */\nexport function validate(object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by a given validation schema.\n */\nexport function validate(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<ValidationError[]>;\n\n/**\n * Validates given object by object's decorators or given validation schema.\n */\nexport function validate(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<ValidationError[]> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validate(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validate(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Validates given object and reject on error.\n */\nexport function validateOrReject(object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by a given validation schema and reject on error.\n */\nexport function validateOrReject(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): Promise<void>;\n\n/**\n * Validates given object by object's decorators or given validation schema and reject on error.\n */\nexport function validateOrReject(schemaNameOrObject: Object|string,\n                         objectOrValidationOptions?: Object|ValidatorOptions,\n                         maybeValidatorOptions?: ValidatorOptions): Promise<void> {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateOrReject(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Performs sync validation of the given object.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by a given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaName: string, object: Object, validatorOptions?: ValidatorOptions): ValidationError[];\n\n/**\n * Validates given object by object's decorators or given validation schema.\n * Note that this method completely ignores async validations.\n * If you want to properly perform validation you need to call validate method instead.\n */\nexport function validateSync(schemaNameOrObject: Object|string,\n                             objectOrValidationOptions?: Object|ValidatorOptions,\n                             maybeValidatorOptions?: ValidatorOptions): ValidationError[] {\n    if (typeof schemaNameOrObject === \"string\") {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as string, objectOrValidationOptions as Object, maybeValidatorOptions);\n    } else {\n        return getFromContainer(Validator).validateSync(schemaNameOrObject as Object, objectOrValidationOptions as ValidatorOptions);\n    }\n}\n\n/**\n * Registers a new validation schema.\n */\nexport function registerSchema(schema: ValidationSchema): void {\n    getMetadataStorage().addValidationSchema(schema);\n}\n"],"names":["ValidationMetadata","[object Object]","args","this","undefined","type","target","propertyName","constraints","constraintCls","validationTypeOptions","validationOptions","message","groups","always","each","context","ValidationSchemaToMetadataTransformer","schema","metadatas","Object","keys","properties","forEach","property","validation","name","options","push","getMetadataStorage","window","global","classValidatorMetadataStorage","MetadataStorage","hasValidationMetaData","validationMetadatas","length","transform","validationMetadata","addValidationMetadata","metadata","constraintMetadatas","grouped","targetConstructor","targetSchema","originalMetadatas","filter","find","group","indexOf","uniqueInheritedMetadatas","Function","prototype","inheritedMetadata","originalMetadata","concat","ValidationError","shouldDecorate","hasParent","parentPath","boldStart","boldEnd","propConstraintFailed","join","formattedProperty","Number","isInteger","children","map","childError","toString","constructor","ValidationTypes","key","isPromise","p","then","ValidationExecutor","validator","validatorOptions","object","validationErrors","metadataStorage","console","warn","targetMetadatas","getTargetValidationMetadatas","groupedMetadatas","groupByPropertyName","forbidUnknownValues","validationError","value","unknownValue","whitelist","definedMetadatas","IS_DEFINED","WHITELIST","Promise","PROMISE_VALIDATION","awaitingPromises","resolvedValue","performValidations","notAllowedProperties","forbidNonWhitelisted","generateValidationError","errors","error","stripEmptyErrors","customValidationMetadatas","CUSTOM_VALIDATION","nestedValidationMetadatas","NESTED_VALIDATION","conditionalValidationMetadatas","CONDITIONAL_VALIDATION","conditionalValidations","customValidations","mapContexts","skipUndefinedProperties","skipNullProperties","skipMissingProperties","nestedValidations","reduce","resultA","resultB","getTargetValidatorConstraints","customConstraintMetadata","async","ignoreAsyncValidations","validationArguments","targetName","Array","Set","Map","validatedValue","instance","validate","promise","isValid","createValidationError","contexts","assign","val","validatedSubValues","from","values","isArray","subValue","some","validatedSubValue","asyncValidatedSubValues","resolve","asyncValidationIsFinishedPromise","all","flatValidatedValues","every","allMetadatas","index","execute","customConstraint","getConstraintType","customValidatorMetadata","dismissDefaultMessages","defaultMessage","messageString","constraint","replace","RegExp","replaceMessageSpecialTokens","Validator","objectOrSchemaName","objectOrValidationOptions","maybeValidatorOptions","executor","coreValidate","reject","defaultContainer","someClass","instances","userContainer","userContainerOptions","useContainer","iocContainer","getFromContainer","get","fallback","fallbackOnErrors","Allow","ConstraintMetadata","registerDecorator","addConstraintMetadata","validationMetadataArgs","buildMessage","impl","eachPrefix","ValidateBy","isDefined","IsDefined","IsOptional","ValidatorConstraint","isAsync","x","y","toLowerCase","Validate","constraintClass","constraintsOrValidationOptions","maybeValidationOptions","ValidateIf","condition","ValidateNested","opts","ValidatePromise","IS_LATLONG","isLatLong","IsLatLong","IS_LATITUDE","isLatitude","IsLatitude","IS_LONGITUDE","isLongitude","IsLongitude","EQUALS","equals","comparison","Equals","NOT_EQUALS","notEquals","NotEquals","IS_EMPTY","isEmpty","IsEmpty","IS_NOT_EMPTY","isNotEmpty","IsNotEmpty","IS_IN","isIn","possibleValues","possibleValue","IsIn","IS_NOT_IN","isNotIn","IsNotIn","IS_DIVISIBLE_BY","isDivisibleBy","num","String","IsDivisibleBy","IS_POSITIVE","isPositive","IsPositive","IS_NEGATIVE","isNegative","IsNegative","MAX","max","Max","maxValue","MIN","min","Min","minValue","MIN_DATE","minDate","date","Date","getTime","MinDate","MAX_DATE","maxDate","MaxDate","CONTAINS","contains","seed","Contains","NOT_CONTAINS","notContains","NotContains","IS_ALPHA","isAlpha","locale","ValidatorJS","IsAlpha","IS_ALPHANUMERIC","isAlphanumeric","IsAlphanumeric","IS_DECIMAL","isDecimal","IsDecimal","IS_ASCII","isAscii","IsAscii","IS_BASE64","isBase64","IsBase64","IS_BYTE_LENGTH","isByteLength","IsByteLength","IS_CREDIT_CARD","isCreditCard","IsCreditCard","IS_CURRENCY","isCurrency","IsCurrency","IS_EMAIL","isEmail","IsEmail","IS_FQDN","isFQDN","IsFQDN","IS_FULL_WIDTH","isFullWidth","IsFullWidth","IS_HALF_WIDTH","isHalfWidth","IsHalfWidth","IS_VARIABLE_WIDTH","isVariableWidth","IsVariableWidth","IS_HEX_COLOR","isHexColor","IsHexColor","IS_HEXADECIMAL","isHexadecimal","IsHexadecimal","isValidationOptions","IS_MAC_ADDRESS","isMACAddress","IsMACAddress","optionsOrValidationOptionsArg","validationOptionsArg","IS_IP","isIP","version","versionStr","IsIP","IS_PORT","isPort","IsPort","IS_ISBN","isISBN","IsISBN","IS_ISIN","isISIN","IsISIN","IS_ISO8601","isISO8601","IsISO8601","IS_JSON","isJSON","IsJSON","IS_JWT","isJWT","IsJWT","IS_LOWERCASE","isLowercase","IsLowercase","IS_MOBILE_PHONE","isMobilePhone","IsMobilePhone","IS_ISO31661_ALPHA_2","isISO31661Alpha2","IsISO31661Alpha2","IS_ISO31661_ALPHA_3","isISO31661Alpha3","IsISO31661Alpha3","IS_MONGO_ID","isMongoId","IsMongoId","IS_MULTIBYTE","isMultibyte","IsMultibyte","IS_SURROGATE_PAIR","isSurrogatePair","IsSurrogatePair","IS_URL","isURL","IsUrl","IS_UUID","isUUID","IsUUID","IS_FIREBASE_PUSH_ID","isFirebasePushId","test","IsFirebasePushId","IS_UPPERCASE","isUppercase","IsUppercase","LENGTH","isLength","Length","isMinLength","isMaxLength","MAX_LENGTH","maxLength","MaxLength","MIN_LENGTH","minLength","MinLength","MATCHES","matches","pattern","modifiers","Matches","modifiersOrAnnotationOptions","IS_PHONE_NUMBER","isPhoneNumber","region","phoneUtil","PhoneNumberUtil","getInstance","phoneNum","parseAndKeepRawInput","isValidNumber","IsPhoneNumber","IS_MILITARY_TIME","isMilitaryTime","IsMilitaryTime","IS_HASH","isHash","algorithm","IsHash","IS_ISSN","isISSN","IsISSN","IS_DATE_STRING","isDateString","IsDateString","IS_BOOLEAN_STRING","isBooleanString","isBoolean","IsBooleanString","IS_NUMBER_STRING","isNumberString","isNumeric","IsNumberString","IS_BASE32","isBase32","IsBase32","IS_BIC","isBIC","IsBIC","IS_BTC_ADDRESS","isBtcAddress","IsBtcAddress","IS_DATA_URI","isDataURI","IsDataURI","IS_EAN","isEAN","IsEAN","IS_ETHEREUM_ADDRESS","isEthereumAddress","IsEthereumAddress","IS_HSL","isHSL","IsHSL","IS_IBAN","isIBAN","IsIBAN","IS_IDENTITY_CARD","isIdentityCard","IsIdentityCard","IS_ISRC","isISRC","IsISRC","IS_LOCALE","isLocale","IsLocale","IS_MAGNET_URI","isMagnetURI","IsMagnetURI","IS_MIME_TYPE","isMimeType","IsMimeType","IS_OCTAL","isOctal","IsOctal","IS_PASSPORT_NUMBER","isPassportNumber","countryCode","IsPassportNumber","IS_POSTAL_CODE","isPostalCode","IsPostalCode","IS_RFC_3339","isRFC3339","IsRFC3339","IS_RGB_COLOR","isRgbColor","includePercentValues","IsRgbColor","IS_SEM_VER","isSemVer","IsSemVer","IS_BOOLEAN","Boolean","IsBoolean","IS_DATE","isDate","isNaN","IsDate","IS_NUMBER","isNumber","Infinity","allowInfinity","allowNaN","maxDecimalPlaces","decimalPlaces","split","isFinite","IsNumber","IS_ENUM","isEnum","entity","k","IsEnum","IS_INT","isInt","IsInt","IS_STRING","isString","IsString","IS_ARRAY","IsArray","IS_OBJECT","isObject","IsObject","ARRAY_CONTAINS","arrayContains","array","ArrayContains","ARRAY_NOT_CONTAINS","arrayNotContains","ArrayNotContains","ARRAY_NOT_EMPTY","arrayNotEmpty","ArrayNotEmpty","ARRAY_MIN_SIZE","arrayMinSize","ArrayMinSize","ARRAY_MAX_SIZE","arrayMaxSize","ArrayMaxSize","ARRAY_UNIQUE","arrayUnique","uniqueItems","a","b","c","ArrayUnique","IS_NOT_EMPTY_OBJECT","isNotEmptyObject","hasOwnProperty","IsNotEmptyObject","IS_INSTANCE","isInstance","targetTypeConstructor","IsInstance","targetType","schemaNameOrObject","validateOrReject","validateSync","registerSchema","addValidationSchema"],"mappings":"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"}